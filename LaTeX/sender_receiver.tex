\section{Implementation of sender and receiver}
\setlength{\abovecaptionskip}{10pt plus 3pt minus 2pt}

Sender and receiver are implemented as two standalone classes, which can be launched by a command line interface with some options. They create all the objects needed, then open some sockets and perform transmission and reception of a file using network coding techniques. We implemented two different versions, one which relies on a Random Fountain coding, and the second that uses LT codes, which is much more difficult to implement but offers better performances.

In order to easily handle encoded packets, we defined the class \texttt{NCpacket}. It has a single private variable, a \texttt{NCpacketContainer} struct that stores an header as a 32 bit integer, a sequence number (\texttt{blockID}) as an 8 bit char, and the payload (i.e. the encoded data) as char array of fixed size. It has constructors that accept either these three parameters or the \texttt{blockID} and the whole chunk of uncoded data, and performs the encoding inside the constructor. 
The header represents a seed which is given to a random number generator in order to create the same encoding vector at sender and receiver side. 

The RF implementation relies on C++ \texttt{rand()} to generate encoding vectors, and \texttt{NCpacket} objects are directly created in sender and receiver main methods.
The LT implementation, instead, uses a factory paradigm to generate \texttt{NCpacket} objects, i.e. it does not directly call the object constructor but creates an helper, \texttt{NCpacketHelper}, which is initialized when the main method of sender (and receiver) is called. This allows to generate only once the Robust Soliton Distribution needed to perform coding and the C++ objects of the \texttt{random} class, which allow a more robust approach for the encoding vector generation. This class has a method that from the seed generates a vector (of variable size) with the position of ones in the encoding vector (which is much more efficient than handling the whole encoding vector, with few ones and thousands of zeros).

The receiver uses objects from a \texttt{TimeCounter} class that performs estimation of time intervals, using the approach inspired to~\cite{rfc6298}. The time intervals of interest are time between the reception of two packets, in order to perform packet gap detection, and the RTT, in order to estimate whether an ACK sent to the sender was received or not. RFC~\cite{rfc6298} proposes a method to estimate RTT for TCP connection, based on some filtering of RTT measurements. However, the order of magnitude of the quantities of interest is much smaller than the minimum value that is returned by an estimator working with~\cite{rfc6298} rules. Therefore some changes have to be made. Let $s_{est}$ be the smoothed estimate of the quantity of interest, $s_{var}$ an estimate of the variance, $s$ a new measurement. Before any measurement is taken, $s_{est}$ is initialized at 50 ms and $s_{var} = s_{est}/2$. Then, once a new value $s$ is available, these two variables are updated as follows
\begin{equation}
	s_{var} = (1-\beta) s_{var}  + \beta |s_{est} - s|
\end{equation}
\begin{equation}
	s_{est} = (1 - \alpha) s_{est} + \alpha s
\end{equation}
where $\alpha = 1/8$, $\beta = 1/4$ as suggested in~\cite{rfc6298}.

The value returned by the \texttt{TimeCounter} object is finally
\begin{equation}
	\max\left\{1, s_{est} + K\times s_{var}  \right\} \mbox{ ms}
\end{equation}
where a granularity of minimum 1 ms is set (instead of 1 s as in~\cite{rfc6298} and $K = 4$. 

\subsection{Sender}
Let's now discuss the implementation of sender and receiver. The retransmission policy is a stop and wait per block, i.e. until a block is not successfully received packets for that block are sent. Flow diagram for the sender is in Fig.~\ref{fig:sender}. Both for the RF and LT implementations a rate $K/N$ is set to guarantee a certain probability of successful decoding. 

Then, given a certain $K$, the sender reads a portion of the file and creates $N$ coded packets (as \texttt{NCpacket} objects). Then it sends them and starts waiting for an acknowledgment from the receiver. When an ack is received, the sender checks for the number of needed packets $P$. If this is 0, it proceeds with the next block to be sent, instead, if it is not, it sends $P$ new encoded packets. In the first block of data, the sender reserves 4 byte for file length. This becomes part of the payload of the first packet, and once decoded at the receiver it allows the receiver to know how much data to expect and terminate correctly once the whole file is received. 

\subsection{Receiver}
The receiver flow diagram is in Fig.~\ref{fig:receiver}. 
For each block of data, it waits for the reception of $N$ packets, then it attempts to decode them. If successful, it appends to the output file the received chunk of data and starts waiting for the next block. If not, it behaves differently in LT and RF implementations. In the latter, when running Gauss elimination, it is possible to know the number $P$ of linearly dependent encoding vectors. Therefore the receiver sends an ack to the sender carrying $P$. When new packets are received, they are all used for decoding, until at least $N$ %TODO check 
linearly independent packets are found.
With LT, instead, this is not possible, therefore an entire new block is asked by sending an ack with $P=N$ to the sender. A possible improvement is to retransmit only a fraction of the $N$ packets and combine them with a random subset of the already received packets. However, if the ratio $K/N$ is low enough, the probability of unsuccessful decoding can be made as small as desired. 

The receiver uses different timers for different events. The first (called pg in Fig.~\ref{fig:receiver}) measures the time between the reception of two packets, in order to perform packet gap detection. If a packet is expected and the timer expires, the receiver assumes it was lost. Since the receiver has to collect $N$ packets before decoding, if the number of received packets $R$ is lower than $N$ then it sends an ack to the sender specifying the number of needed packets $P = N - R$. The second timer is used when waiting for the first packet after an ack. It thus waits for the ack to be received, new packets to be encoded and for the first to be received at the receiver (this interval is defined as a \textit{round trip time} (RTT)). If it expires, the ack is sent again. Both these timers use estimates provided by \texttt{TimeCounter} objects, however in order to make the system less aggressive (expecially in localhost, where intervals are very small and difficult to handle for the OS) the value of the estimate is scaled by 10 times. A third timer is used when a new block is expected, it is based on the RTT estimate but it scaled by 100 in order to allow for possible delays in reading the file from disk and encoding a whole new block. The scaling factors are empirical values, and can be adapted for usage on different networks.

\subsection{PER estimation at sender}
The sender has also a \texttt{PER\_MODE}, if this is enabled it estimates the \textit{Packet Error Rate} (PER) of the channel and tries to adapt to it. The estimation is done with a moving average on a window of past block transmissions. In particular the sender records the average number of packets $P_b$ needed to successfully transmit each block, and estimates the PER as $PER = 1 - N/P_b$. Then once the sender needs to send $P$ packets, it sends $P/(1-PER)$ packets trying to prevent channel losses without needing retransmission. This lowers the efficiency of the system, but decreases the time needed to transmit the file.

\begin{sidewaysfigure}
\captionsetup{justification=centering,margin=3cm}

\begin{subfigure}{0.5\hsize}\centering
    \begin{tikzpicture}[node distance = 2cm, scale=0.8, every node/.style={scale=0.8}]
	\node (start) [startstop] {Init};
	\node (setup) [process, below of=start, align=center] {Open socket, initialize\\useful variable, open input file};
	\node (filesetup) [process, below of=setup, align=center, yshift=-1cm] {Compute file size\\ number of blocks $B$\\set number of tx block $b = 0$};
	\node (while) [decision, below of=filesetup, yshift=-1cm] {$b < B$?};
	\node (stop) [startstop, below left of=while, yshift=-1cm, xshift=-2cm] {Stop};
	\node (read) [process, below right of=while, yshift=-1cm, xshift=1.2cm, align=center] {Read data, set\\packets needed $P = N$};
	\node (send) [process, below of=read] {Encode and send $P$ packets};
	\node (waitack) [process, left of=send, xshift=-4cm] {Wait for ACK};
	\node (ack) [decision, below of=send, align=center, yshift=-1cm] {Packet needed\\$P$ = 0?};
	\node (ackrx) [process, left of=ack, xshift=-4cm, align=center] {Update $P$};

	\draw[arrow] (start) -- (setup);
	\draw[arrow] (setup) -- (filesetup);
	\draw[arrow] (filesetup) -- (while);
	\draw[arrow] (while) -- node[anchor=west] {yes} (read);
	\draw[arrow] (while) -- node[anchor=east] {no} (stop);
	\draw[arrow] (read) -- (send);
	\draw[arrow] (send) -- (waitack);
	\draw[arrow] (ackrx) -- (ack);
	\draw[arrow] (ack) -- node[anchor=east] {no} (send);
	\draw[arrow] (ack) -| node[anchor=west] {yes} ([xshift=+1cm]send.south east) |- node[anchor=west] {$b$++} (while);
	\draw[darrow] (waitack) -- node[anchor=west] {Ack received} (ackrx);
\end{tikzpicture}
\caption{Sender flowchart}
\label{fig:sender}

\end{subfigure}%
%\hfill <-- it is superfluous 
\begin{subfigure}{0.5\hsize}\centering

	% picture of realization diagram
	\begin{tikzpicture}[node distance = 2cm,scale=0.8, every node/.style={scale=0.8}]
		\node (start) [startstop] {Init};
		\node (setup) [process, below of=start, yshift=-0.5cm, align=center] {Open socket, initialize\\useful variables\\received packet $R=0$};
		\node (while) [decision, below right of=setup, yshift=-1.5cm, xshift=2cm,align=center] {File download\\completed?};
		\node (stop) [startstop, below left of=setup, yshift=-1.5cm, xshift=-2cm] {Stop};

		\node (waitpck) [process, below of=while, yshift=-1cm, align=center] {Wait for packet\\start timer T};
		
		\node (recv) [process, below of=stop, yshift=-1cm, align=center] {$R= R+1$};

		\node (numpck) [decision, below of=recv, yshift=-0.3cm, align=center] {$R<N$?};

		\node (decode) [process, below of=numpck, align=center] {Decode};

		\node (success) [decision, below of=decode, align=center] {Successful\\decoding?};

		\node (write) [process, below of=success, yshift=-1cm, align=center] {Write decoded chunk\\Send ack with $P=0$};

		\node (timer) [below of=waitpck, align=center] {};

		\node (sendack) [process, below of=timer, yshift=-0.3cm, align=center] {Send ack with\\$P=N-R$};

		\node (sendun) [process, below of=sendack, align=center] {Send ack with\\$P=N$};

		\draw[arrow] (start) -- (setup);	
		\draw[arrow] (setup) -- (while);
		\draw[arrow] (while) -- node[anchor=west] {no, T=new\_block} (waitpck);
		\draw[arrow] (while) -- node[anchor=north] {yes} (stop);
		\draw[arrow] (recv) -- (numpck);
		\draw[arrow] (numpck) -- node[anchor=east] {yes} (decode);
		\draw[arrow] (numpck) -- node[anchor=south, yshift=+0.1cm] {no, T=pg} (waitpck);
		\draw[arrow] (decode) -- (success);
		\draw[arrow] (success) -- node[anchor=east] {yes} (write);
		\draw[arrow] (success) -- node[anchor=north] {no} (sendun);
		\draw[arrow] (sendun) -| node[anchor=south, yshift=-0.7cm] {T=ack} ([xshift=+2cm]sendack.east) |-  (while);
		\draw[arrow] (sendack) -- node[anchor=east] {T=ack} (waitpck);
		\draw[arrow] (write) -| ([xshift=+3cm]sendack.east) |- ([yshift=+1cm]while.north east) -| (while.north);

		\draw[darrow] (waitpck) -- node[anchor=south] {Receive packet} (recv);
		\draw[darrow] (waitpck) -| ([xshift=+1cm]waitpck.south east) |- node[anchor=north east, yshift=0.6cm, rotate=270] {Timer expired} (sendack);

		
		%\draw[arrow] (ackrx) -- (ack);
		%\draw[arrow] (ack) -- node[anchor=east] {no} (send);
		%\draw[arrow] (ack) -| node[anchor=west] {yes} ([xshift=+0.25cm]send.south east) |- node[anchor=west] {$b$++} (while);
	\end{tikzpicture}
	\caption{Receiver flowchart. T can be a timer of three different kind, pg for packet gap detection, ack for RTT, new\_block for new blocks (RTT + read + encoding)}
	\label{fig:receiver}

\end{subfigure}

\caption{Sender and receiver flowchart. The dashed arrow represents a possible flow.}
\label{fig:flowchart}
\end{sidewaysfigure}


